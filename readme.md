# 五子棋AI项目 (Gomoku AI)

基于Alpha-Beta剪枝算法的五子棋AI实现，使用Minimax搜索算法结合启发式评估函数。

## 项目结构

```
Gomoku/
├── run.py              # 主游戏界面和交互逻辑
├── gomoku.py           # 游戏核心逻辑（棋盘、落子、胜负判定）
├── alpha_beta_search.py # Alpha-Beta搜索算法实现
├── game_eval.py        # 棋盘评估函数和启发式搜索
├── fonts/              # 字体文件
└── test_*.py           # 测试文件
```

## 游戏模式

### 🎮 游戏模式说明

#### 1. 双人对战模式
- **操作方式**: 在主菜单按 `1` 键选择
- **游戏规则**: 两名玩家轮流下棋，黑棋先手
- **交互功能**: 
  - 鼠标点击下棋
  - 点击"悔棋"按钮撤销上一步
  - 点击"保存棋局"按钮保存当前状态
- **适用场景**: 朋友间对弈、教学演示

#### 2. AI对战模式
- **操作方式**: 在主菜单按 `2` 键选择
- **游戏规则**: 玩家执黑棋，AI执白棋，玩家先手
- **AI特性**: 
  - 使用Alpha-Beta剪枝的Minimax搜索算法
  - 搜索深度4层，中等强度
  - 实时显示"AI思考中..."提示
- **交互功能**:
  - 玩家下棋后AI自动思考并落子
  - 点击"悔棋"按钮撤销AI和玩家的最后两步
  - 点击"保存棋局"按钮保存当前状态（自动撤销AI最后一步以便分析）
- **适用场景**: 练习棋艺、测试AI能力

#### 3. 残局加载模式
- **操作方式**: 在主菜单按 `3` 键选择
- **功能说明**: 加载之前保存的棋局文件
- **文件格式**: JSON格式，存储在`board_snapshots/`目录
- **操作步骤**:
  1. 在主菜单按 `3` 进入残局选择界面
  2. 按数字键 `1-0` 选择要加载的残局文件
  3. 按 `ESC` 键返回主菜单
- **加载信息**: 显示游戏模式、当前玩家、历史步数等
- **适用场景**: 分析特定棋局、继续未完成的对局、AI行为调试

### 🎯 界面功能

#### 高亮显示
- **最后一步**: 最后落子的棋子用红色边框高亮显示
- **鼠标提示**: 鼠标悬停时显示半透明的落子提示
- **星位标记**: 棋盘上的五个星位用黑点标记

#### 信息显示
- **当前玩家**: 显示当前轮到哪一方下棋
- **游戏模式**: 显示当前是双人对战还是AI对战
- **历史步数**: 显示当前对局的总步数
- **AI状态**: AI思考时显示"AI思考中..."提示

#### 按钮功能
- **悔棋按钮**: 撤销上一步或上两步（AI模式）
- **保存按钮**: 保存当前棋局到JSON文件

## 当前功能

### ✅ 已完成

- **游戏核心逻辑**: 完整的五子棋游戏规则实现
- **AI搜索算法**: Alpha-Beta剪枝的Minimax搜索
- **评估函数**: 基于棋型的启发式评估（五连、活四、冲四、活三等）
- **用户界面**: Pygame图形界面，支持三种游戏模式
- **交互功能**: 悔棋、保存棋局、残局加载、AI思考提示
- **移动生成**: 启发式移动排序，优先考虑有威胁的位置
- **高亮显示**: 最后一步红色边框高亮，鼠标悬停提示

### 🎯 当前AI能力

- **搜索深度**: 4层深度
- **评估精度**: 支持多种棋型识别和评分
- **响应时间**: 中等（需要进一步优化）

## 性能分析

### 当前瓶颈

1. **搜索速度**: 4层深度搜索时间较长
2. **移动生成**: 每次生成所有可能移动，计算量大
3. **评估函数**: 复杂的正则表达式匹配影响性能
4. **内存使用**: 大量字符串操作和模式匹配

### 优化方向

1. **算法优化**: 改进搜索算法和剪枝策略
2. **启发式优化**: 更智能的移动生成和排序
3. **代码优化**: 减少计算开销，提高执行效率
4. **并行化**: 利用多线程/多进程加速搜索

## TODO 优化计划

### 🚀 性能优化 (优先级: 高)

#### 1. 搜索算法优化

- [ ] **迭代加深搜索**: 实现迭代加深，在时间限制内达到最大深度
- [ ] **历史启发式**: 记录历史最佳移动，优化移动排序
- [ ] **空着裁剪**: 实现Null Move Pruning，减少搜索分支
- [ ] **静态搜索**: 在叶子节点进行静态搜索，提高评估精度
- [ ] **转置表**: 实现哈希表缓存搜索结果，避免重复计算

#### 2. 移动生成优化

- [ ] **威胁空间搜索**: 只考虑有威胁的位置，大幅减少搜索空间
- [ ] **增量更新**: 只重新计算受影响的区域，而不是整个棋盘
- [ ] **缓存机制**: 缓存移动生成结果，避免重复计算
- [ ] **早期剪枝**: 在移动生成阶段就进行初步剪枝

#### 3. 评估函数优化

- [ ] **位运算优化**: 使用位运算替代正则表达式，提高速度
- [ ] **增量评估**: 只评估受影响的区域，而不是整个棋盘
- [ ] **评估缓存**: 缓存评估结果，避免重复计算
- [ ] **简化评估**: 在搜索早期使用简化评估函数

#### 4. 代码层面优化

- [ ] **数据结构优化**: 使用更高效的数据结构
- [ ] **内存管理**: 减少内存分配和垃圾回收
- [ ] **并行化**: 实现多线程搜索
- [ ] **Cython加速**: 关键函数用Cython重写

### 🧠 棋力提升 (优先级: 中)

#### 1. 评估函数增强

- [ ] **更精细的棋型**: 增加更多棋型识别（如眠三、眠二等）
- [ ] **位置权重**: 考虑棋子位置的重要性（中心位置权重更高）
- [ ] **组合棋型**: 识别和评估组合棋型（如双活三等）
- [ ] **防守权重**: 增加防守的权重，平衡攻防

#### 2. 开局库

- [ ] **开局数据库**: 建立五子棋开局库
- [ ] **开局评估**: 在开局阶段使用开局库指导搜索
- [ ] **开局学习**: 从对局中学习新的开局变化

#### 3. 终局优化

- [ ] **终局数据库**: 建立小规模终局数据库
- [ ] **必胜必败判断**: 快速判断必胜必败局面
- [ ] **终局搜索**: 在终局阶段使用更精确的搜索

### 🎮 用户体验 (优先级: 低)

#### 1. 界面优化

- [ ] **AI难度选择**: 提供多个AI难度级别
- [ ] **思考时间控制**: 允许用户设置AI思考时间
- [ ] **对局记录**: 保存和回放对局记录
- [ ] **统计分析**: 显示AI思考过程和统计信息

#### 2. 功能扩展

- [ ] **网络对战**: 支持网络对战功能
- [ ] **AI训练**: 实现AI自我对弈训练
- [ ] **棋谱分析**: 分析历史棋谱，提取策略

## 技术细节

### 搜索算法

- **算法**: Alpha-Beta剪枝的Minimax搜索
- **深度**: 当前4层，目标6-8层
- **剪枝**: 基础Alpha-Beta剪枝

### 评估函数

- **棋型识别**: 五连、活四、冲四、活三、冲三、活二等
- **评分系统**: 基于威胁程度的评分
- **计算方式**: 正则表达式匹配 + 模式统计

### 移动生成

- **策略**: 启发式移动生成
- **排序**: 基于威胁程度的移动排序
- **范围**: 当前考虑所有空位，目标只考虑威胁位置

## 运行方式

```bash
# 安装依赖
pip install pygame numpy

# 运行游戏
python run.py
```

## 性能目标

- **搜索深度**: 从4层提升到6-8层
- **响应时间**: 从数秒降低到1秒以内
- **棋力水平**: 达到业余高手水平
- **内存使用**: 优化内存占用，支持长时间对局

## 贡献指南

欢迎提交Issue和Pull Request来改进项目！

## 许可证

MIT License
